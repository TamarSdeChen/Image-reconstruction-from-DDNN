# -*- coding: utf-8 -*-
"""optic_simulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DzpZI5iOnFwXYl1qnOVGjuYpJ57LAug4
"""
#!pip install torchmetrics
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
import torch
import torchvision
import time
import os
# imports:
import math
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal


def rect(x):
  #rectangle function
  return abs(x)<=1/2


def RS_estimation(size_in, L, lambda_in, z):
  # implementation of Fresnel propogation
  # propagation - transfer function approach
  # assumes same x and y side lengths and
  # uniform sampling
  # u1 - source plane field
  # size_in = M -> [M,~]=size(u1)
  # L - source and observation plane side length
  # lambda - wavelength
  # z - propagation distance
  # u2 - observation plane field
  dx=L/size_in #sample interval
  k=2*np.pi/lambda_in #wavenumber
  #freq coords - FROM -1/(2*dx) TO 1/(2*dx)-1/L IN 1/L steps
  fx=np.arange(  (-1/(2*dx))  ,  (1/(2*dx)-1/L)+(1/L)  ,  (1/L)  ) # check if size is ok (+-1)
  FX,FY=np.meshgrid(fx,fx)
  H_temp=np.exp(1j*k*z*np.sqrt(1-(2*np.pi/k*FX)**2+(2*np.pi/k*FY)**2)) #trans func of RS
  ## ask matan how to - change range only to fx^2+fy^2 < 1/lambda^2
  rs_range = FX**2+FY**2
  rs_range_mask = np.where(rs_range < (1/lambda_in**2) ,1,0)
  H = H_temp * rs_range_mask ## only if in range, otherwise 0
  H=np.fft.fftshift(H) #shift trans func
  return H

def Fresnel_estimation(size_in, L, lambda_in, z):
  # implementation of Fresnel propogation
  # propagation - transfer function approach
  # assumes same x and y side lengths and
  # uniform sampling
  # u1 - source plane field
  # size_in = M -> [M,~]=size(u1)
  # L - source and observation plane side length
  # lambda - wavelength
  # z - propagation distance
  # u2 - observation plane field
  dx=L/size_in #sample interval
  k=2*np.pi/lambda_in #wavenumber
  #freq coords - FROM -1/(2*dx) TO 1/(2*dx)-1/L IN 1/L steps
  fx=np.arange(  (-1/(2*dx))  ,  (1/(2*dx)-1/L)+(1/L)  ,  (1/L)  ) # check if size is ok (+-1)
  FX,FY=np.meshgrid(fx,fx)
  H=np.exp(-1j*np.pi*lambda_in*z*(FX**2+FY**2)) #trans func
  H=np.fft.fftshift(H) #shift trans func
  return H


## implementation of Rayleighâ€“Sommerfeld propogation layer
class propTF(nn.Module):
  def __init__(self, H):
    super().__init__() ## inherit nn.module method
    self.H = H

  def forward(self, u1):
    ## numpy to pytorch -> work with tensor to use GPU
    # u1 - source plane field
    U1 = np.fft.fft2(np.fft.fftshift(u1)) # maybe change later
    U2 = self.H * U1
    u2 = np.fft.ifftshift(np.fft.ifft2(U2))
    return u2  # inverse fft, center obs field

lambda_in = 0.75 * (10 ** -3)
# mnist
transform = torchvision.transforms.Compose([
    torchvision.transforms.Resize([90,90]),
    torchvision.transforms.RandomRotation([-10, 10]),
    torchvision.transforms.RandomAffine(degrees=[0.9, 1.1],translate=(2.13 * lambda_in, 2.13 * lambda_in)),
    torchvision.transforms.Pad([15,15]),
    torchvision.transforms.ToTensor(),
])
transform_1 = torchvision.transforms.Compose([
    torchvision.transforms.Resize([90,90]),
    torchvision.transforms.RandomRotation([-10, 10]),
    torchvision.transforms.RandomAffine(degrees=[0.9, 1.1],translate=(2.13 * lambda_in, 2.13 * lambda_in)),
    torchvision.transforms.Pad([15,15]),

])
train_set = torchvision.datasets.MNIST('../data_simu', train=True, download=True, transform=transform)
# train_samples = torch.randperm(train_set.data.shape[0])[:5000]

train_loader = torch.utils.data.DataLoader(train_set, batch_size=60)
target= train_loader.dataset.data[labels == 6]
n_target_samples = len(target)
random_index = int(np.random.random() * n_target_samples)
G_k = transform_1(target[random_index].unsqueeze(0).type(torch.float))




# mnist_samples = torch.randperm(mnist_samples.data.shape[0])[:1]
u1 = mnist_samples
# define optic simulation parameters - tbd from article
L1 = 0.5  # side length
lambda_in = 0.75 * (10 ** -3)  # wavelength in m
k = 2 * np.pi / lambda_in  # wavenumber
z = 20 * (10 ** -3)  # propagation dist (m)
M = 120
M = 250 #number of samples
dx1 = L1/M #src sample interval
x1= np.arange(-L1/2,L1/2, dx1) #src coords
y1= x1


z = 20 * (10 ** -3)  # propagation dist (m)
X1,Y1=np.meshgrid(x1,y1)
I1=np.abs(u1**2) #src irradiance

# # sqr_beam propagation example
# L1 = 0.5 #side length
# M = 250 #number of samples
# dx1 = L1/M #src sample interval
# x1= np.arange(-L1/2,L1/2, dx1) #src coords
# y1= x1
#
# lambda_in=0.5*(10**-6) #wavelength
# k=2*np.pi/lambda_in #wavenumber
# w=0.051 #source half width (m)
# z=2000 #propagation dist (m)
# X1,Y1=np.meshgrid(x1,y1)
# # u1=rect(X1/(2*w))*rect(Y1/(2*w)) #src field
# I1=np.abs(u1**2) #src irradiance


# ## plot
# ## plot gray image
# plt.title("z = 0 (m)")
# plt.imshow(I1,cmap=plt.cm.gray)
# plt.xlabel("x (m)")
# plt.ylabel("y (m)")
# plt.show()

# ## choose approximation -
# H = RS_estimation(u1.shape[0], L1, lambda_in, z) ##RS approximation
# # H = Fresnel_estimation(u1.shape[0], L1, lambda_in, z) ##Fresnel approximation
#
# layer = propTF(H)
# u2=layer.forward(u1) #propagation
#
# x2=x1 #obs coords
# y2=y1
# I2=abs(u2**2) #obs irrad
#
# ## plot graphs
# fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(10, 6))
#
# ## plot irradiance image
# axs[0, 0].imshow(I2,cmap=plt.cm.gray)
# axs[0, 0].set_title("z = 2000(m)")
# axs[0, 0].set_xlabel("x (m)")
# axs[0, 0].set_ylabel("y (m)")
#
# ## plot irradiance profile
# axs[0, 1].plot(x2,I2[int(M/2+1),:])
# axs[0, 1].set_title("z = 2000(m)")
# axs[0, 1].set_xlabel("x (m)")
# axs[0, 1].set_ylabel("Irradiance")
#
# ## plot field magnitude profile
# axs[1, 0].plot(x2,np.abs(u2[int(M/2+1),:]))
# axs[1, 0].set_title("z = 2000(m)")
# axs[1, 0].set_xlabel("x (m)")
# axs[1, 0].set_ylabel("Magnitude")
#
# ## plot field phase profile
# axs[1, 1].plot(x2,np.unwrap(np.angle(u2[int(M/2+1),:],deg=False)))
# axs[1, 1].set_title("z = 2000(m)")
# axs[1, 1].set_xlabel("x (m)")
# axs[1, 1].set_ylabel("Phase (rad)")
#
# fig.tight_layout()
# plt.show()